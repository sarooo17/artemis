"use client";

import { useState, useEffect, useRef } from "react";
import { useParams, useRouter } from "next/navigation";
import ProtectedRoute from "@/components/ProtectedRoute";
import Navbar from "@/components/Navbar";
import { useAuth } from "@/contexts/AuthContext";

type AIResponseBarState = "thinking" | "preview" | "expanded" | "hidden";

interface ChatMessage {
  id: string;
  userMessage: string;
  aiResponse: string;
  timestamp: Date;
}

function ChatPageContent() {
  const params = useParams();
  const router = useRouter();
  const [inputValue, setInputValue] = useState("");
  
  // AI Response Bar states
  const [aiBarState, setAiBarState] = useState<AIResponseBarState>("hidden");
  const [currentAiResponse, setCurrentAiResponse] = useState("");
  const [currentUserMessage, setCurrentUserMessage] = useState("");
  const [chatHistory, setChatHistory] = useState<ChatMessage[]>([]);
  const [thinkingMessage, setThinkingMessage] = useState("Thinking...");
  const [scrollbarVisible, setScrollbarVisible] = useState(false);
  const [shouldScrollToLastMessage, setShouldScrollToLastMessage] = useState(false);
  
  const autoHideTimerRef = useRef<NodeJS.Timeout | null>(null);
  const barHoverRef = useRef(false);
  const scrollContainerRef = useRef<HTMLDivElement>(null);
  const scrollbarTimerRef = useRef<NodeJS.Timeout | null>(null);
  const lastMessageRef = useRef<HTMLDivElement>(null);
  const savedScrollPositionRef = useRef(0);

  // Auto-hide timer management
  const startAutoHideTimer = () => {
    if (autoHideTimerRef.current) {
      clearTimeout(autoHideTimerRef.current);
    }
    autoHideTimerRef.current = setTimeout(() => {
      if (!barHoverRef.current && aiBarState === "preview") {
        setAiBarState("hidden");
      }
    }, 3000);
  };

  const cancelAutoHideTimer = () => {
    if (autoHideTimerRef.current) {
      clearTimeout(autoHideTimerRef.current);
      autoHideTimerRef.current = null;
    }
  };

  // Handle state transitions
  useEffect(() => {
    if (aiBarState === "preview") {
      startAutoHideTimer();
    } else {
      cancelAutoHideTimer();
    }
    
    return () => cancelAutoHideTimer();
  }, [aiBarState]);

  // Recupera il messaggio iniziale e simula risposta AI
  useEffect(() => {
    const initialMessage = sessionStorage.getItem(`chat-${params.id}-initial`);
    if (initialMessage) {
      sessionStorage.removeItem(`chat-${params.id}-initial`);
      setCurrentUserMessage(initialMessage);
      setAiBarState("thinking");
      
      // Simula thinking messages
      const thinkingMessages = ["Thinking...", "Understanding your request...", "Checking context...", "Preparing the answer..."];
      let messageIndex = 0;
      const thinkingInterval = setInterval(() => {
        messageIndex = (messageIndex + 1) % thinkingMessages.length;
        setThinkingMessage(thinkingMessages[messageIndex]);
      }, 2000);
      
      // Simula risposta AI dopo un delay
      setTimeout(() => {
        clearInterval(thinkingInterval);
        const aiResponse = 'This is a simulated AI response. In production, this would be generated by your AI service based on the user input: "' + initialMessage + '"';
        setCurrentAiResponse(aiResponse);
        
        // Add to history
        const newMessage: ChatMessage = {
          id: Date.now().toString(),
          userMessage: initialMessage,
          aiResponse: aiResponse,
          timestamp: new Date()
        };
        setChatHistory(prev => [...prev, newMessage]);
        setShouldScrollToLastMessage(true); // Auto-scroll to first message
        
        setAiBarState("preview");
      }, 6000);
    }
  }, [params.id]);

  const handleSendMessage = () => {
    if (!inputValue.trim()) return;
    
    const userMessage = inputValue;
    setCurrentUserMessage(userMessage);
    setInputValue("");
    setAiBarState("thinking");
    setThinkingMessage("Thinking...");
    setShouldScrollToLastMessage(true); // Reset scroll to new message
    
    // Simula thinking messages
    const thinkingMessages = ["Thinking...", "Understanding your request...", "Checking context...", "Preparing the answer..."];
    let messageIndex = 0;
    const thinkingInterval = setInterval(() => {
      messageIndex = (messageIndex + 1) % thinkingMessages.length;
      setThinkingMessage(thinkingMessages[messageIndex]);
    }, 2000);
    
    // Simula risposta AI
    setTimeout(() => {
      clearInterval(thinkingInterval);
      const aiResponse = 'AI response to: "' + userMessage + '". This would be generated by your AI service. This is a longer response to test the preview truncation feature and how it handles multiple lines of text.';
      setCurrentAiResponse(aiResponse);
      
      // Add to history
      const newMessage: ChatMessage = {
        id: Date.now().toString(),
        userMessage: userMessage,
        aiResponse: aiResponse,
        timestamp: new Date()
      };
      setChatHistory(prev => [...prev, newMessage]);
      
      setAiBarState("preview");
    }, 6000);
  };

  const handleKeyPress = (e: React.KeyboardEvent) => {
    if (e.key === 'Enter' && !e.shiftKey) {
      e.preventDefault();
      handleSendMessage();
    }
  };

  // Scrollbar auto-hide management
  const showScrollbar = () => {
    setScrollbarVisible(true);
    if (scrollbarTimerRef.current) {
      clearTimeout(scrollbarTimerRef.current);
    }
    scrollbarTimerRef.current = setTimeout(() => {
      setScrollbarVisible(false);
    }, 3000);
  };

  const handleScroll = () => {
    showScrollbar();
    if (scrollContainerRef.current) {
      savedScrollPositionRef.current = scrollContainerRef.current.scrollTop;
    }
  };

  const handleScrollMouseEnter = () => {
    setScrollbarVisible(true);
    if (scrollbarTimerRef.current) {
      clearTimeout(scrollbarTimerRef.current);
    }
  };

  const handleScrollMouseLeave = () => {
    if (scrollbarTimerRef.current) {
      clearTimeout(scrollbarTimerRef.current);
    }
    scrollbarTimerRef.current = setTimeout(() => {
      setScrollbarVisible(false);
    }, 3000);
  };

  const handleBarClick = () => {
    if (aiBarState === "preview") {
      setAiBarState("expanded");
      cancelAutoHideTimer();
    }
  };

  const handleBarMouseEnter = () => {
    barHoverRef.current = true;
    if (aiBarState === "preview") {
      cancelAutoHideTimer();
    }
  };

  const handleBarMouseLeave = () => {
    barHoverRef.current = false;
    if (aiBarState === "preview") {
      startAutoHideTimer();
    }
  };

  const handleExpandedClose = () => {
    if (scrollContainerRef.current) {
      savedScrollPositionRef.current = scrollContainerRef.current.scrollTop;
    }
    setAiBarState("preview");
  };

  // Handle scroll position when expanding/collapsing
  useEffect(() => {
    if (aiBarState === "expanded" && scrollContainerRef.current) {
      // Small delay to ensure DOM is ready
      setTimeout(() => {
        if (shouldScrollToLastMessage && lastMessageRef.current && scrollContainerRef.current) {
          // Calculate position to align AI message top with container top
          const containerRect = scrollContainerRef.current.getBoundingClientRect();
          const messageRect = lastMessageRef.current.getBoundingClientRect();
          const scrollOffset = messageRect.top - containerRect.top + scrollContainerRef.current.scrollTop;
          
          // Add some padding to avoid the gradient overlay (32px for the spacer + gradient)
          scrollContainerRef.current.scrollTop = scrollOffset - 20;
          setShouldScrollToLastMessage(false); // Reset flag after scrolling
        } else if (!shouldScrollToLastMessage) {
          // Restore saved scroll position only if not auto-scrolling
          scrollContainerRef.current!.scrollTop = savedScrollPositionRef.current;
        }
      }, 100);
    }
  }, [aiBarState, shouldScrollToLastMessage]);

  const handleOverlayClick = (e: React.MouseEvent) => {
    if (e.target === e.currentTarget) {
      handleExpandedClose();
    }
  };

  const handleShowLastAnswer = () => {
    setAiBarState("preview");
  };

  return (
    <div className="w-screen h-screen bg-white gap-2 flex">
      <Navbar />

      {/* WORKSPACE Container - takes full space for generative UI */}
      <div 
        className="relative flex h-full w-full overflow-hidden"
        onClick={aiBarState === "expanded" ? handleExpandedClose : undefined}
      >
        {/* Generative UI Area - occupies entire workspace */}
        <div className="absolute inset-0 overflow-auto">
          {/* Qui verrà generata la UI dinamica */}
          
        </div>

        {/* AI Response Bar - Unified Panel */}
        {aiBarState !== "hidden" && (
          <div className={`absolute left-1/2 -translate-x-1/2 w-full max-w-[calc(48rem+1rem)] px-8 z-50 transition-all duration-300 ${
            aiBarState === "expanded" ? "bottom-6" : "bottom-26"
          }`}>
            <div 
              onClick={(e) => {
                e.stopPropagation();
                if (aiBarState === "preview") handleBarClick();
              }}
              onMouseEnter={handleBarMouseEnter}
              onMouseLeave={handleBarMouseLeave}
              className={`bg-white rounded-[34px] shadow-md border-2 border-neutral-100 backdrop-blur-sm transition-all duration-300 relative ${
                aiBarState === "expanded" ? "h-96 shadow-2xl" : "min-h-[52px]"
              } ${
                aiBarState === "preview" ? "cursor-pointer hover:shadow-lg" : ""
              }`}
            >
              {/* Close button - only in expanded */}
              {aiBarState === "expanded" && (
                <button
                  onClick={handleExpandedClose}
                  className="absolute top-4 right-4 z-10 w-8 h-8 flex items-center justify-center rounded-full bg-white hover:bg-neutral-100 transition-colors shadow-md border border-neutral-200"
                >
                  <span className="text-neutral-600 text-xl">×</span>
                </button>
              )}

              {/* Content */}
              <div 
                className={`${aiBarState === "expanded" ? "h-full" : "px-6 py-3"}`}
              >
                {aiBarState === "expanded" && <div className="h-8" />}
                <div 
                  ref={scrollContainerRef}
                  onScroll={handleScroll}
                  onMouseEnter={handleScrollMouseEnter}
                  onMouseLeave={handleScrollMouseLeave}
                  className={aiBarState === "expanded" ? `overflow-y-auto px-6 pb-12 space-y-4 ai-panel-scroll ${scrollbarVisible ? 'scrollbar-visible' : 'scrollbar-hidden'}` : ""}
                  style={aiBarState === "expanded" ? {
                    scrollbarWidth: 'thin',
                    scrollbarColor: '#d4d4d4 transparent',
                    height: 'calc(100% - 64px)'
                  } : undefined}
                >
                <div className="absolute top-8 left-0 right-0 h-8 bg-linear-to-t from-transparent to-white pointer-events-none" />
                {aiBarState === "expanded" ? (
                  // Expanded: Show full chat history
                  chatHistory.map((message, index) => (
                    <div 
                      key={message.id} 
                      className="space-y-3"
                    >
                      {/* User message */}
                      <div className="flex justify-end group">
                        <div className="relative">
                          <div className="bg-blue-500 text-white rounded-2xl px-4 py-2 max-w-md">
                            <p className="text-sm">{message.userMessage}</p>
                          </div>
                          <div className="opacity-0 group-hover:opacity-100 transition-opacity text-xs text-neutral-400 text-right mt-1">
                            {message.timestamp.toLocaleTimeString()}
                          </div>
                        </div>
                      </div>
                      
                      {/* AI response */}
                      <div 
                        className="flex justify-start"
                        ref={index === chatHistory.length - 1 ? lastMessageRef : null}
                      >
                        <div className="max-w-2xl">
                          <p className="text-sm text-neutral-800 leading-relaxed">{message.aiResponse}</p>
                        </div>
                      </div>
                    </div>
                  ))
                ) : aiBarState === "thinking" ? (
                  // Thinking state
                  <div className="flex items-center gap-3">
                    <div className="w-2 h-2 bg-blue-500 rounded-full animate-bounce"></div>
                    <div className="w-2 h-2 bg-blue-500 rounded-full animate-bounce" style={{ animationDelay: '0.1s' }}></div>
                    <div className="w-2 h-2 bg-blue-500 rounded-full animate-bounce" style={{ animationDelay: '0.2s' }}></div>
                    <span className="text-sm text-neutral-500 ml-2">{thinkingMessage}</span>
                  </div>
                ) : (
                  // Preview state
                  <div className="relative max-h-[72px] overflow-hidden">
                    <p className="text-sm text-neutral-800 leading-relaxed line-clamp-3">
                      {currentAiResponse}
                    </p>
                  </div>
                )}
                </div>
              </div>

              {/* Bottom gradient fade - only show when needed */}
              {aiBarState === "expanded" && (
                <div className="absolute bottom-0 left-0 right-0 h-24 bg-linear-to-t from-white to-transparent pointer-events-none rounded-b-[34px]" />
              )}
              {aiBarState === "preview" && currentAiResponse.length > 200 && (
                <div className="absolute bottom-0 left-0 right-0 h-6 bg-linear-to-t from-white to-transparent pointer-events-none rounded-b-[26px]" />
              )}
            </div>
          </div>
        )}

        {/* Floating Input Bar with Hot Zone - fixed position, overlays the UI */}
        <div 
          className={`absolute bottom-8 left-1/2 -translate-x-1/2 w-full max-w-3xl px-8 z-50 ${aiBarState === "hidden" && currentAiResponse ? 'group' : ''}`}
          onClick={(e) => e.stopPropagation()}
        >
          {/* Hot zone extension above input bar */}
          {aiBarState === "hidden" && currentAiResponse && (
            <div className="h-28 -mb-16 pointer-events-auto" />
          )}
          
          {/* Show button on hover */}
          {aiBarState === "hidden" && currentAiResponse && (
            <div 
              className="absolute top-0 left-1/2 -translate-x-1/2 opacity-0 group-hover:opacity-100 transition-opacity pointer-events-none"
              style={{ zIndex: 10 }}
            >
              <button
                onClick={handleShowLastAnswer}
                className="flex items-center gap-2 px-4 py-2 bg-white rounded-full shadow-lg border border-neutral-200 hover:bg-neutral-50 transition-colors pointer-events-auto"
              >
                <span className="text-sm text-neutral-700">▲</span>
              </button>
            </div>
          )}
          
          <div className={`p-0.5 bg-linear-to-bl from-blue-200 via-neutral-50 to-blue-200 rounded-full ${aiBarState === "expanded" ? 'shadow-none' : 'shadow-lg'}`}>
            <div className="flex items-center gap-3 bg-white rounded-full px-2 py-2 backdrop-blur-sm">
              <button className="w-9 h-9 rounded-full text-gray-600 hover:text-gray-700 text-3xl font-light transition-colors">
                +
              </button>
              <input
                type="text"
                value={inputValue}
                onChange={(e) => setInputValue(e.target.value)}
                onKeyPress={handleKeyPress}
                placeholder="Type your message..."
                className="flex-1 outline-none text-base text-neutral-900 placeholder-neutral-400 bg-transparent"
              />
              <button 
                onClick={handleSendMessage}
                className={`w-9 h-9 rounded-full flex items-center cursor-pointer justify-center transition-all ${inputValue ? 'bg-blue-500' : 'bg-blue-100'}`}
              >
                <img 
                  src={inputValue ? "/icon-submit.svg" : "/icon-voice.svg"} 
                  alt={inputValue ? "Send" : "Voice"} 
                  className="w-4 h-4 object-contain transition-all" 
                />
              </button>
            </div>
          </div>
        </div>
      </div>
    </div>
  );
}

export default function ChatPage() {
  return (
    <ProtectedRoute>
      <ChatPageContent />
    </ProtectedRoute>
  );
}
